## 1번.
[카테고리 별 도서 판매량 집계하기](https://school.programmers.co.kr/learn/courses/30/lessons/144855)

```SQL
SELECT
    B.CATEGORY,
    SUM(S.SALES) AS "TOTAL_SALES"
FROM BOOK B
JOIN BOOK_SALES S
ON B.BOOK_ID = S.BOOK_ID AND DATE_FORMAT(SALES_DATE, '%Y-%m') = '2022-01'
GROUP BY B.CATEGORY
ORDER BY B.CATEGORY ASC;
```


## 2번.
[오랜 기간 보호한 동물(2)](https://school.programmers.co.kr/learn/courses/30/lessons/59411)


### 정답 1
```SQL
SELECT O.ANIMAL_ID, O.NAME
FROM ANIMAL_INS I
JOIN ANIMAL_OUTS O
ON I.ANIMAL_ID = O.ANIMAL_ID
ORDER BY (DATEDIFF(O.DATETIME, I.DATETIME) + 1) DESC
LIMIT 2;
```

### 정답 2
```SQL
SELECT
    (DATEDIFF(O.DATETIME, I.DATETIME) + 1) AS PERIOD,
    O.ANIMAL_ID,
    O.NAME
FROM ANIMAL_INS I
JOIN ANIMAL_OUTS O
ON I.ANIMAL_ID = O.ANIMAL_ID
GROUP BY (DATEDIFF(O.DATETIME, I.DATETIME) + 1)
ORDER BY (DATEDIFF(O.DATETIME, I.DATETIME) + 1) DESC
LIMIT 2;
```


## 3번.
[대여 기록이 존재하는 자동차 리스트 구하기](https://school.programmers.co.kr/learn/courses/30/lessons/157341)


```SQL
SELECT C.CAR_ID
FROM CAR_RENTAL_COMPANY_CAR C
JOIN CAR_RENTAL_COMPANY_RENTAL_HISTORY R
ON C.CAR_ID=R.CAR_ID AND C.CAR_TYPE = '세단'
WHERE MONTH(R.START_DATE) = '10'
GROUP BY C.CAR_ID
ORDER BY C.CAR_ID DESC;
```
> 중복 제거를 위해 GROUP BY 안하고 DISTINCT 쓰는 것도 가능!


## 4번
[즐겨찾기가 가장 많은 식당 정보 출력하기](https://school.programmers.co.kr/learn/courses/30/lessons/131123)

> GROUP BY를 쓸 수 없는 상황임!<BR/> 
FOOD_TYPE으로 그룹화해야되는데, SELECT에서 반환해야되는 다른 컬럼들이 있으니까...<BR/>
GROUP BY를 쓸거면 
> 1. SELECT에 쓴 컬럼들이 모두 GROUP BY 안에 있거나, 2. 집계함수를 사용해야하는데 ('GROUP BY 컬럼'이라면 그 컬럼을 기준으로 그룹화를 할텐데, GROUP BY에 쓰이지 않는 컬럼들은 뭘 기준으로 해야될지 SQL은 알 수 없으므로...)

<BR/>


### 정답 1 : 서브쿼리
```SQL
SELECT FOOD_TYPE, REST_ID, REST_NAME, FAVORITES
FROM REST_INFO AS R1
WHERE FAVORITES = (
    SELECT MAX(FAVORITES) 
    FROM REST_INFO AS R2 
    WHERE R1.FOOD_TYPE = R2.FOOD_TYPE
)
ORDER BY FOOD_TYPE DESC;
```

### 정답 2: 윈도우 함수
```SQL
SELECT FOOD_TYPE, REST_ID, REST_NAME, FAVORITES
FROM (
    SELECT FOOD_TYPE, REST_ID, REST_NAME, FAVORITES,
           RANK() OVER (PARTITION BY FOOD_TYPE ORDER BY FAVORITES DESC) AS rnk
    FROM REST_INFO
) sub
WHERE rnk = 1
ORDER BY FOOD_TYPE DESC;
```

- RANK() OVER (PARTITION BY FOOD_TYPE ORDER BY FAVORITES DESC)
    - 같은 FOOD_TYPE 내에서 FAVORITES가 가장 많은 식당을 찾음
- WHERE rnk = 1
    - 가장 즐겨찾기 수가 높은 식당만 선택



## 5번
[조건에 맞는 사용자와 총 거래금액 조회하기](https://school.programmers.co.kr/learn/courses/30/lessons/164668)

```SQL
SELECT
    U.USER_ID,
    NICKNAME,
    SUM(PRICE) AS TOTAL_SALES
FROM USED_GOODS_BOARD B
JOIN USED_GOODS_USER U
ON B.WRITER_ID = U.USER_ID AND STATUS = 'DONE'
GROUP BY U.USER_ID, U.NICKNAME
HAVING SUM(PRICE) >= 700000
ORDER BY TOTAL_SALES ASC;
```


## 6번
[없어진 기록 찾기](https://school.programmers.co.kr/learn/courses/30/lessons/59042)

### 정답 1 : RIGHT JOIN
```SQL
SELECT O.ANIMAL_ID, O.NAME
FROM ANIMAL_INS I
RIGHT OUTER JOIN ANIMAL_OUTS O
ON I.ANIMAL_ID = O.ANIMAL_ID
WHERE I.ANIMAL_ID IS NULL 
ORDER BY O.ANIMAL_ID ASC;
```


### 정답 2 : NOT EXISTS
```SQL
SELECT O.ANIMAL_ID, O.NAME
FROM ANIMAL_OUTS O
WHERE NOT EXISTS (
    SELECT 1
    FROM ANIMAL_INS I
    WHERE I.ANIMAL_ID = O.ANIMAL_ID)
ORDER BY O.ANIMAL_ID ASC;
```

![SQL11](./image/SQL11.png)